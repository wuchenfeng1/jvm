## jvm 笔记

+ 1.java代码的执行流程
    ```
    前端编译器 -> class 文件 ->jvm中执行
                              （类加载器->  字节码校验器-> jni编译器和解释器 执行）
                              高级语言->汇编->机器指令->cpu
    ```
+ 2.基于栈式架构的特点：
  ```
      设计和实现更简单，适用于资源受限的系统；
      避开了寄存器的分配难题：使用零地址指令方式分配
      指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
      不需要硬件支持，可移植性更好，更好实现跨平台
    ```
+ 3 java翻编译指令： javap -v Main.class

+ 4 jvm的生命周期   启动 -> 执行 -> 退出
+   趁程序还在运行的时候，赶快使用 jps 指令查看当前正在运行的进程

 ![Image text](https://raw.githubusercontent.com/hongmaju/light7Local/master/img/productShow/01.png)
 
+ 5.jclasslib bytecode viewer 是一个可以可视化已编译Java类文件和所包含的字节码的工具， BinaryViewer 查看字节码文件，其开头均为 CAFE BABE （魔法值），如果出现不合法的字节码文件

+ 6 java的执行顺序
```
  首先JVM加载这个类的执行顺序
                   -》 执行静态代码块  JVM加载类时执行，仅执行一次 先执行
                   -》 main方法 
                   -》 实例代码块 在每次创建对象时执行
                   -》 构造器   在每次创建对象时执行
                   -》 执行调用方法
   如果是继承，创建对象
      -》 首先执行父类的静态代码块
     -》 儿子静态代码块
     -》 父亲实例代码块
     -》 父亲构造器
     -》 儿子实例代码块
     -》 儿子构造器               
```

+ 类加载的顺序（加载 --> 链接（验证 --> 准备 --> 解析） --> 初始化）
 - 变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1
+ 双亲委派机制原理
         ```
        1.如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
        如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
        如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
        父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常
        
        优点：
        避免类的重复加载
        保护程序安全，防止核心API被随意篡改
        自定义类：java.lang.String 没有屌用
        自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）
        ```
+  沙箱安全机制
         ```
        1.自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，
        而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），
        报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。
        2.这样可以保证对java核心源代码的保护，这就是沙箱安全机制。
       
        ```
+ 在JVM中表示两个class对象是否为同一个类存在两个必要条件：
```
类的完整类名必须一致，包括包名
加载这个类的ClassLoader（指ClassLoader实例对象）必须相同
换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的
```
+ 对类加载器的引用
```
JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的
如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中
当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的
```
+ Java程序对类的使用方式分为：主动使用和被动使用。主动使用，又分为七种情况：
```
创建类的实例
访问某个类或接口的静态变量，或者对该静态变量赋值
调用类的静态方法
反射（比如：Class.forName(“com.atguigu.Test”)）
初始化一个类的子类
Java虚拟机启动时被标明为启动类的类
JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化
除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）
```
+ 类的加载 --> 验证 --> 准备 --> 解析 --> 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区
+ 线程独有：独立包括程序计数器、栈、本地方法栈   线程间共享：堆、堆外内存（永久代或元空间、代码缓存）
+ jvm线程
```
线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行
在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射
当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收
操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法
如果一个线程抛异常，并且该线程时进程中最后一个守护线程，那么进程将停止
```
+  程序计数器
```
PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。
左边的数字代表指令地址（指令偏移），即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令

```
+ 面试题 使用PC寄存器存储字节码指令地址有什么用呢？或者问 为什么使用 PC 寄存器来记录当前线程的执行地址呢？
```
1.因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
2.JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
```
+ 面试题 PC寄存器为什么被设定为私有的？
```
1.我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？

2.为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

3.由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

4.这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。
```
+ CPU 时间片
```
CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

```
+ 虚拟机栈
```
由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。
优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。
```
+ 内存中的栈与堆 首先栈是运行时的单位，而堆是存储的单位
```
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
堆解决的是数据存储的问题，即数据怎么放，放哪里
```
+ 虚拟机栈的生命周期
```
生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了
```
+ 虚拟机栈的作用
``
主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。
局部变量，它是相比于成员变量来说的（或属性）
基本数据类型变量 VS 引用类型变量（类、数组、接口）
``
+ 虚拟机栈的特点
```
栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：
每个方法执行，伴随着进栈（入栈、压栈）
执行结束后的出栈工作
对于栈来说不存在垃圾回收问题（栈存在溢出的情况）
```
+ 面试题：栈中可能出现的异常
```
Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。
如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。
如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。
```
+ 设置栈内存大小
```
我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。
-Xss1024m		// 栈内存为 1024MBS
-Xss1024k		// 栈内存为 1024KB
设置线程的最大栈空间：256KB
```
+ 栈的存储单位
```
每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在
在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
```
+ 栈的运行原理
```
1.JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则

2.在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的

    1..这个栈帧被称为当前栈帧（Current Frame）
    2.与当前栈帧相对应的方法就是当前方法（Current Method）
    3.定义这个方法的类就是当前类（Current Class）
3.执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

4.如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

5.不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

6.如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

7.Java方法有两种返回函数的方式，但不管使用哪种方式，都会导致栈帧被弹出

    1.一种是正常的函数返回，使用return指令
    2.另外一种是抛出异常
```



